/*
 * [구현 문제점 기록]
 * 
 * <2011_1102_최원준>
 * 1 - 숙련도 처리에 관한 문제
 * 딕셔너리에 모든 아이템 목록을 넣고,
 * 플레이어가 아이템을 만들 때 마다 플레이어의 아이템 목록에 제작 숙련도와 함께 들어가야 한다.
 * 즉, 플레이어는 아이템의 제작 숙련도 목록을 들고 있어야 한다.
 * 
 * 시도방법 1 - 제작아이템만 숙련도를 가져야 하므로 무기 클래스의 멤버변수로 숙련도를 넣는다.
 * 시도방법 2 - 제작 숙련도 목록만 플레이어가 따로 가지고 있는다.
 * => 방법2로 시도 중.
 *  
 * 2 - 아이템의 오브젝트 관리 및 인벤토리 내부와 외부 이미지 적용방법에 관한 문제 (2d, 3d이미지 스위칭 관련)
 * 어떤 오브젝트가 RectTransform 좌표를 가지기만 하면 컴포넌트 onOff를 통하여 2d와 3d를 동시에 표현이 가능함을 발견하였음. 
 * 다만 좌표, 앵커의 조정 및 관리 그리고 컴포넌트 및 이미지 스위칭 측면에서 비효율적이라고 판단되어 
 * 인벤토리에서 외부로 아이템이 반출될 때는 새롭게 오브젝트를 생성하여 보여주도록 한다. (2d, 3d오브젝트를 따로 관리)
 * 
 * 
 * <2023_1103_v2.0_최원준>
 * 1 - 리스트 인벤토리에 단순한 Item클래스인 개념아이템이 아닌 오브젝트를 담는 것으로 변경해야 함을 알았음.
 * (게임에서 표현되는 오브젝트를 넣으면 Transform관리가 가능해지고, 개념 아이템인 Item클래스의 참조값을 들고 있기 때문)
 * 
 * 2 - 인벤토리 인덱스까지 같이 담아서 구조체 리스트로 만들어야 하는가에 대한 의문.
 * 같이 담는다면 코드 로직이 복잡해지고, 슬롯의 남은 자리를 확인하기 위해 모든 리스트를 꺼내봐야 하는 비효율이 발생하게 됨.
 * 
 * => 인덱스만 따로 분리하기로 함. 
 * => 인덱스를 분리해보았으나, 한 번에 코드를 묶어서 관리하기가 어렵다.
 * 아이템 클래스에 생성 당시 부터 슬롯의 인덱스를 저장하며, 슬롯이 바뀔 때마다 이 정보가 수정되도록 변경
 * 추가 발견 사항) 
 * abstract 클래스의 멤버로 position을 등록하고 자식 인스턴스에서 position을 수정하고
 * 부모 클래스로 폴리모프하여 position을 호출해보면 자식 인스턴스에서 수정한 position값이 반영되어 있는 것을 확인.
 * 
 * 
 * 3 - 메서드 리팩토링 과정에서 제네릭으로 상속한 클래스를 받는 방법
 * T 형식으로 ItemWeapon, ItemMisc 등의 자료형을 받은 다음, Item 자료형으로 폴리모프해서 담아야 하는데,
 * 
 * T weaponItem = (T)weaponDic[itemName].Clone();
 * ...
 * itemObject.GetComponent<ItemInfo>().item = weaponItem;
 * 
 * T 형식 자료형은 Item 자료형으로 인식해주지 않는다. 
 * => 즉, T형식이 Item을 상속하는 자료형만 받겠다고 알려줘야 함.
 * 
 * 4 - ItemInfo클래스의 OnItemAdd메서드가 호출 될 때 스프라이트 이미지를 참조하지 못하는 문제 발생.
 * innerImage.sprite = item.Image.innerSprite;
 * => 
 * 해결) innerImage 컴포넌트가 Start상에서 잡고 있었으나, 
 * 다른 스크립트에서 해당 프리팹을 Instantiate하면서 OnAddItem을 곧바로 호출하기 때문에 
 * Start와 OnAddItem의 호출 시점이 겹치게 되었음.
 * Start를 OnEnable로 변경.
 * 
 * 추가 발견사항) 리소스 폴더에 스프라이트 이미지를 집어넣었는데, 불러올 때 스프라이트로 잡히지 않았다.
 * 확인하여보니 오브젝트 하위에 스프라이트가 들어가있으며, 이 오브젝트는 Texture2D라는 구조를 가진것으로 판명되었음.
 * 
 * 그리고 Texture2D에서 스프라이트 이미지를 가지고 오기 위해서는 
 * texture = Resources.Load<Texture2D>("myObject");
 * Sprite sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));
 * 와 같은 방식으로 생성해서 가져와야 함을 알 수 있었다.
 * 
 * 이는 화면 캡쳐 로직에도 활용됨을 알 수 있음.
 * texture = ScreenCapture.CaptureScreenshotAsTexture();
 * Sprite sprite = Sprite.Create(...);
 * preview.sprite = sprite;
 * 
 * 
 * <2023_1106_v4.0_최원준>
 * 1- 상태창 표기오류
 * a. 기본성능 500을 줘서 무기를 생성하면, 최종성능 750으로 되어있는문제 
 * - 해결. 잠금변수 초기화를 true로 해야하는데 false로 하였음.
 * b. 최종등급 Normal로 반환하는 문제 
 * - 해결. 최종등급 연산에서 if문 순서가 앞에서 먼저 걸렸음.
 */
 